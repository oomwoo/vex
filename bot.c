#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(Sensor, dgtl1,  PANIC,          sensorDigitalIn)
#pragma config(Motor,  port1,           LEFT,          tmotorVex393_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port10,          RIGHT,         tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

// REVISION

// TODO
// - "forget" mistake button: send this command
// - CMD_STOP button

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

const short CMD_NO_COMMAND = 0;
const short CMD_STOP = 1;
const short CMD_GO_FORWARD = 2;
const short CMD_GO_BACK = 3;
const short CMD_TURN_LEFT = 4;
const short CMD_TURN_RIGHT = 5;
const short CMD_SPIN_LEFT = 6;
const short CMD_SPIN_RIGHT = 7;

unsigned int nXmitChars = 0;
unsigned int nRecvChars = 0;

const short JOY_MIN_VAL = 64;

short lcdView = 1;
short lcdViewPrev = 0;
short joyFwdBack = 0;
short joyLeftRight = 0;
short joySpin = 0;
short cmd = CMD_NO_COMMAND;
short bmLeft = 0;
short bmRight = 0;

bool panic = false;
bool forget = false;
bool humanControl = true;

char uartCmd, uartValue;

bool isButtonPressed(tSensors port)
{
	return (bool) (1 - SensorValue[port]);
}

short JoystickToCommand(short joyFwdBack, short joyLeftRight, short joySpin)
{
	if (joyFwdBack > JOY_MIN_VAL)
	{
		return CMD_GO_FORWARD;
	}
	else if (joyFwdBack < -JOY_MIN_VAL)
	{
		return CMD_GO_BACK;
	}
	else if (joyLeftRight > JOY_MIN_VAL)
	{
		return CMD_TURN_RIGHT;
	}
	else if (joyLeftRight < -JOY_MIN_VAL)
	{
		return CMD_TURN_LEFT;
	}
	else if (joySpin > JOY_MIN_VAL)
	{
		return CMD_SPIN_RIGHT;
	}
	else if (joySpin < -JOY_MIN_VAL)
	{
		return CMD_SPIN_LEFT;
	}
	else
		return CMD_NO_COMMAND;
}

void CommandToBaseMotorPower(short cmd, short* bmLeft, short* bmRight)
{
	switch (cmd)
	{
		case CMD_GO_FORWARD:
			*bmLeft = 127;
			*bmRight = 127;
			break;
		case CMD_GO_BACK:
			*bmLeft = -127;
			*bmRight = -127;
			break;
		case CMD_TURN_RIGHT:
			*bmLeft = 127;
			*bmRight = 0;
			break;
		case CMD_TURN_LEFT:
			*bmLeft = 0;
			*bmRight = 127;
			break;
		case CMD_SPIN_RIGHT:
			*bmLeft = 127;
			*bmRight = -127;
			break;
		case CMD_SPIN_LEFT:
			*bmLeft = -127;
			*bmRight = 127;
			break;
		default:
			*bmLeft = 0;
			*bmRight = 0;
	}
}

void UpdateLCD()
{
	string mainBattery;

	if (nLCDButtons != 0)
		lcdView = nLCDButtons;

	switch (lcdView) {
	case 1:
		if (lcdView != lcdViewPrev)
		{
			displayLCDString(0, 0, "C   F   P   H   ");
			displayLCDString(1, 0, "    V           ");
		}
		//Display command, who has control
		displayLCDNumber(0, 1, cmd, 1);
		displayLCDNumber(0, 5, forget, 1);
		displayLCDNumber(0, 9, panic, 1);
		displayLCDNumber(0, 13, humanControl, 1);

		// Display battery voltage
		sprintf(mainBattery, "%1.2f", nImmediateBatteryLevel/1000.0);
		displayLCDString(1, 0, mainBattery);
		break;
	case 2:
		// UART vars
		if (lcdView != lcdViewPrev)
		{
			displayLCDString(0, 0, "Tx              ");
			displayLCDString(1, 0, "Rx              ");
		}
		displayLCDNumber(0, 3, nXmitChars, 10);
		displayLCDNumber(1, 3, nRecvChars, 10);
		break;
	case 4:
		if (lcdView != lcdViewPrev)
		{
			displayLCDString(0, 0, "F    T     S    ");
			displayLCDString(1, 0, "L       R       ");
		}
		displayLCDNumber(0, 1, joyFwdBack, 4);
		displayLCDNumber(0, 6, joyLeftRight, 4);
		displayLCDNumber(0, 12, joySpin, 4);
		displayLCDNumber(1, 2, bmLeft, 4);
		displayLCDNumber(1, 10, bmRight, 4);
		break;
	}
	lcdViewPrev = lcdView;
}

void Init()
{
	bLCDBacklight = true;				// Turn on LCD Backlight
	lcdViewPrev = 0; 						// Force full LCD update

//	configureSerialPort(uartOne, uartUserControl);
//	setBaudRate(uartOne, baudRate115200);
}

void QueueUartChar(char value)
{
	nXmitChars++;
	sendChar(uartOne, value);
	while (!bXmitComplete(uartOne))
	{
		sleep(0);
	}
}

char toHex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

void SendUartCmd(char cmd, char value)
{
	char nibble;
	QueueUartChar(cmd);

	nibble = value >> 4;
	QueueUartChar(toHex[nibble]);

	nibble = value & 0x0f;
	QueueUartChar(toHex[nibble]);

	QueueUartChar(0x0a);	// Line feed
}

short GetUartChar()
{
	short rcvChar;

	rcvChar = getChar(uartOne);
	if (rcvChar != -1)
		nRecvChars++;

	return rcvChar;

}

char GetUartCharWait()
{
	short rcvChar;

	while (true)
	{
		rcvChar = GetUartChar();
		if (rcvChar == -1)
			sleep(0);
		else
			return (char) rcvChar;
	}
}

bool isValidHexChar(char ch)
{
	return ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F'));
}

char Char2Nibble(char nibble)
{
	if (nibble <= '9')
		return nibble - '0';

	return nibble - 'A';
}

char GetUartCmd(char* value)
{
	short rcvChar;

	while (true)
	{
		rcvChar = GetUartChar();
		if (rcvChar == -1)
			return 0;

		char ch = (char) rcvChar;

		// valid command?
		if (ch >= 'a' && ch <= 'z' || ch > 'F' && ch <= 'Z')
		{
			char cmd = ch;

			char val1 = GetUartCharWait();
			if (!isValidHexChar(val1))
				continue;

			char val2 = GetUartCharWait();
			if (!isValidHexChar(val2))
				continue;

			char ret = GetUartCharWait();
			if (ret != '\n')
				continue;

			*value = Char2Nibble(val1) << 4 + Char2Nibble(val2);
			return cmd;
		}
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void UserControlFunction()
{
	// User control code here, inside the loop

	Init();

	while(true) {

		if (isButtonPressed(PANIC))
			panic = true;

		////////////////////////////////////////////////////////////////////////////
		// BASE motor control
		////////////////////////////////////////////////////////////////////////////
		joyLeftRight = vexRT[Ch1];
		joyFwdBack = vexRT[Ch2];
		joySpin = vexRT[Ch4];
		cmd = JoystickToCommand(joyFwdBack, joyLeftRight, joySpin);
		if (vexRT[Btn5U] || vexRT[Btn5D] || vexRT[Btn6U] || vexRT[Btn6D])
			cmd = CMD_STOP;

		// Transfer control to robot?
		if (vexRT[Btn7U])
			humanControl = false;

		// Moving joystick controls returns control to human
		if (cmd != CMD_NO_COMMAND)
			humanControl = true;

		// Human made a mistake: "forget" last few seconds of training
		forget = (bool) vexRT[Btn7D];

		// Send command to Raspberry Pi
		SendUartCmd('c', (char) cmd);
		SendUartCmd('f', (char) forget);

		while (true)
		{
			uartCmd = GetUartCmd(&uartValue);
			if (uartCmd == 0)
				break;

			switch (uartCmd)
			{
				case 'c':
					cmd = uartValue;
					break;
			}
		}

		CommandToBaseMotorPower(cmd, &bmLeft, &bmRight);

		if (panic)
		{
			bmLeft = 0;
			bmRight = 0;
		}

		motor[LEFT] = bmLeft;
		motor[RIGHT] = bmRight;

		////////////////////////////////////////////////////////////////////////////
		// DISPLAY
		////////////////////////////////////////////////////////////////////////////

		UpdateLCD();

		// Motor values can only be updated every 20ms
		wait1Msec(20);

	}

	// Never executed; just to suppress a warning
	UserControlCodePlaceholderForTesting();
}

task usercontrol()
{
	UserControlFunction();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();
}
