#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(Sensor, dgtl1,  stop_button,          sensorDigitalIn)
#pragma config(Motor,  port1,           LEFT,          tmotorVex393_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port10,          RIGHT,         tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "UART_Comm_Link_Includes.c"    // Connects VEX Cortex UART to Raspberry Pi

enum UserCommand
{
	USER_CMD_NONE,
	USER_CMD_STOP,
	USER_CMD_DRIVE_FORWARD,
	USER_CMD_DRIVE_BACKWARD,
	USER_CMD_TURN_LEFT,
	USER_CMD_TURN_RIGHT,
	USER_CMD_SPIN_LEFT,
	USER_CMD_SPIN_RIGHT
};

const short JOY_MIN_VAL = 64;

short lcdView = 1;
short lcdViewPrev = 0;
short joyFwdBack = 0;
short joyLeftRight = 0;
short joySpin = 0;
short bmLeft = 0;
short bmRight = 0;
UserCommand UserCmd = USER_CMD_NONE;
LinkCommand LinkCmd = LINK_CMD_NONE;

bool stop_button_pressed = false;
bool forget = false;
bool humanControl = true;

char uartCmd, uartValue;

bool isButtonPressed(tSensors port)
{
	return (bool) (1 - SensorValue[port]);
}

UserCommand JoystickToCommand(short joyFwdBack, short joyLeftRight, short joySpin)
{
	if (joyFwdBack > JOY_MIN_VAL)
	{
		return USER_CMD_DRIVE_FORWARD;
	}
	else if (joyFwdBack < -JOY_MIN_VAL)
	{
		return USER_CMD_DRIVE_BACKWARD;
	}
	else if (joyLeftRight > JOY_MIN_VAL)
	{
		return USER_CMD_TURN_RIGHT;
	}
	else if (joyLeftRight < -JOY_MIN_VAL)
	{
		return USER_CMD_TURN_LEFT;
	}
	else if (joySpin > JOY_MIN_VAL)
	{
		return USER_CMD_SPIN_RIGHT;
	}
	else if (joySpin < -JOY_MIN_VAL)
	{
		return USER_CMD_SPIN_LEFT;
	}
	else
		return USER_CMD_NONE;
}

void CommandToBaseMotorPower(short UserCmd, short* bmLeft, short* bmRight)
{
	switch (UserCmd)
	{
		case USER_CMD_DRIVE_FORWARD:
			*bmLeft = 127;
			*bmRight = 127;
			break;
		case USER_CMD_DRIVE_BACKWARD:
			*bmLeft = -127;
			*bmRight = -127;
			break;
		case USER_CMD_TURN_RIGHT:
			*bmLeft = 127;
			*bmRight = 0;
			break;
		case USER_CMD_TURN_LEFT:
			*bmLeft = 0;
			*bmRight = 127;
			break;
		case USER_CMD_SPIN_RIGHT:
			*bmLeft = 127;
			*bmRight = -127;
			break;
		case USER_CMD_SPIN_LEFT:
			*bmLeft = -127;
			*bmRight = 127;
			break;
		default:
			*bmLeft = 0;
			*bmRight = 0;
	}
}

void UpdateLCD()
{
	string mainBattery;

	if (nLCDButtons != 0)
		lcdView = nLCDButtons;

	switch (lcdView) {
	case 1:
		if (lcdView != lcdViewPrev)
		{
			displayLCDString(0, 0, "u   F   P   H   ");
			displayLCDString(1, 0, "    V       L   ");
		}
		//Display command, who has control
		displayLCDNumber(0, 1, UserCmd, 1);
		displayLCDNumber(0, 5, forget, 1);
		displayLCDNumber(0, 9, stop_button_pressed, 1);
		displayLCDNumber(0, 13, humanControl, 1);
		displayLCDNumber(1, 13, LinkCmd, 2);

		// Display battery voltage
		sprintf(mainBattery, "%1.2f", nImmediateBatteryLevel/1000.0);
		displayLCDString(1, 0, mainBattery);
		break;
	case 2:
		// UART vars
		if (lcdView != lcdViewPrev)
		{
			displayLCDString(0, 0, "Tx              ");
			displayLCDString(1, 0, "Rx              ");
		}
		displayLCDNumber(0, 3, nXmitChars, 10);
		displayLCDNumber(1, 3, nRecvChars, 10);
		break;
	case 4:
		if (lcdView != lcdViewPrev)
		{
			displayLCDString(0, 0, "F    T     S    ");
			displayLCDString(1, 0, "L       R       ");
		}
		displayLCDNumber(0, 1, joyFwdBack, 4);
		displayLCDNumber(0, 6, joyLeftRight, 4);
		displayLCDNumber(0, 12, joySpin, 4);
		displayLCDNumber(1, 2, bmLeft, 4);
		displayLCDNumber(1, 10, bmRight, 4);
		break;
	}
	lcdViewPrev = lcdView;
}

void Init()
{
	bLCDBacklight = true;				// Turn on LCD Backlight
	lcdViewPrev = 0; 						// Force full LCD update

//	configureSerialPort(uartOne, uartUserControl);
//	setBaudRate(uartOne, baudRate115200);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

void UserControlFunction()
{
	// User control code here, inside the loop

	Init();

	while(true) {

		if (isButtonPressed(stop_button))
			stop_button_pressed = true;

		////////////////////////////////////////////////////////////////////////////
		// User command
		////////////////////////////////////////////////////////////////////////////
		joyLeftRight = vexRT[Ch1];
		joyFwdBack = vexRT[Ch2];
		joySpin = vexRT[Ch4];
		UserCmd = JoystickToCommand(joyFwdBack, joyLeftRight, joySpin);

		if (vexRT[Btn5U] || vexRT[Btn5D] || vexRT[Btn6U] || vexRT[Btn6D])
			UserCmd = USER_CMD_STOP;

		////////////////////////////////////////////////////////////////////////////
		// Control Raspberry Pi
		////////////////////////////////////////////////////////////////////////////

		LinkCmd = LINK_CMD_NONE;
		forget = false;

		if (vexRT[Btn8R])
		{
			// Forget last few seconds of training (if the human operator made a mistake)
			forget = true;
			LinkCmd = LINK_CMD_FORGET;
		}
		else if (vexRT[Btn7R])
		{
			// Have Raspberry Pi start capturing video and user commands (joystick, buttons, etc.)
			LinkCmd = LINK_CMD_START_CAPTURE;
		}
		else if (vexRT[Btn7L])
		{
			// Have Raspberry Pi stop capturing video, user commands (joystick, buttons, etc.)
			LinkCmd = LINK_CMD_STOP_CAPTURE;
		}
		else if (vexRT[Btn7U])
		{
			// Transfer control from human operator to robot (autonomous control)
			humanControl = false;
			LinkCmd = LINK_CMD_AUTONOMOUS_CONTROL;
		}
		else if (vexRT[Btn8U])
		{
			// End training successfully - Raspberry Pi disconnects and uploads captured data
			LinkCmd = LINK_CMD_TERMINATE_AND_UPLOAD;
		}
		else if (vexRT[Btn8D])
		{
			// Abort training - Raspberry Pi disconnects, does not upload captured data
			LinkCmd = LINK_CMD_TERMINATE;
		}
		else if (vexRT[Btn7D])
		{
			// Highest priority command
			// Transfer control from robot to the human operator (manual control)
			humanControl = true;
			LinkCmd = LINK_CMD_MANUAL_CONTROL;
		}

		// TODO Moving joystick controls returns control to human

		// Send command(s) to Raspberry Pi
		if (LinkCmd != LINK_CMD_NONE)
			SendUartCmd('L', (char) LinkCmd);
		if (UserCmd != USER_CMD_NONE)
			SendUartCmd('u', (char) UserCmd);
		if (LinkCmd != LINK_CMD_NONE || UserCmd != USER_CMD_NONE)
			SendUartLF();		// Finish command(s) with line feed

		// Receive command from Raspberry Pi
		while (true)
		{
			uartCmd = GetUartCmd(&uartValue);
			if (uartCmd == 0)
				break;

			switch (uartCmd)
			{
				case 'c':
					if (!humanControl)
						UserCmd = (UserCommand) uartValue;
					break;
			}
		}

		////////////////////////////////////////////////////////////////////////////
		// Execute user command
		////////////////////////////////////////////////////////////////////////////

		CommandToBaseMotorPower(UserCmd, &bmLeft, &bmRight);

		// If something goes wrong with the bot,
		// user can stop the bot by pressing the stop_button_pressed button
		if (stop_button_pressed)
		{
			bmLeft = 0;
			bmRight = 0;
		}

		motor[LEFT] = bmLeft;
		motor[RIGHT] = bmRight;

		////////////////////////////////////////////////////////////////////////////
		// DISPLAY
		////////////////////////////////////////////////////////////////////////////

		UpdateLCD();

		// Motor values can only be updated every 20ms
		wait1Msec(20);

	}

	// Never executed; just to suppress a warning
	UserControlCodePlaceholderForTesting();
}

task usercontrol()
{
	UserControlFunction();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();
}
